# Project Specification

## Working Title: **Sonsuz TÃ¼rkiye**

---

## 1. High-Level Concept

You are implementing a **browser-based sandbox crafting game** inspired by *Infinite Craft* by Neal Agarwal. In that game, players start with four basic elements (water, fire, earth, wind), drag elements onto each other to combine them, and get new elements generated by an AI language model. Players can go on infinitely, discovering memes, concepts, characters, etc.

This project replicates that **core mechanic**, but with a strong focus on:

- **Turkish internet culture**
(memes, slang, Twitter/X jokes, EkÅŸi SÃ¶zlÃ¼k vibes, YouTube culture, influencer names, etc.)
- **General Turkish culture**
(history, cities, food, TV shows, football culture, literature, music, religious and social references handled respectfully).
- **Modern global culture**, but always biased toward Turkish context first.

This **first edition will use the Google Gemini API** as the generative model responsible for creating new elements from pairs of existing elements.

> Key rule: You implement logic, UI, storage, API integration, prompts, filters as specified here.
You do not invent game design yourself. All behaviors must match this document.
> 

---

## 2. Core Goals

1. **Endless element crafting** from a small set of starting elements.
2. **Strong Turkish bias**: AI output must heavily lean toward Turkish culture and Turkish internet, while still being able to reference global things.
3. **Safe, non-toxic content** with basic moderation. Implement a switch here so that we can test a little bit of toxicism later.
4. **Simple, clean, fast web UI** that works on desktop and mobile browsers.

---

## 3. Gameplay Overview

### 3.1 Starting State

- Player opens the web app and sees:
    - A **main canvas area** in the center/left.
    - A **sidebar** on the right listing all discovered elements.
    - A **top bar** with the game name, settings (language toggle, dark mode, etc.).
- At the very beginning, the player has **four base elements** in the sidebar:
    - **Su**
    - **AteÅŸ**
    - **Toprak**
    - **Hava**

For v1, **language of element names is Turkish**. English can be added later as a separate property but is not required to display.

### 3.2 Core Interaction Loop

1. Player drags an element from the sidebar onto the canvas.
2. Player drags another element onto the first one (or near it).
3. When the player releases the second element over the first:
    - The game attempts to **combine (elementA, elementB)**.
    - Use **Gemini API** to generate a new element (name + emoji).
    - Apply **post-processing + safety checks**.
    - Show an animation.
4. The new element appears on the canvas and in the sidebar.

There is **no explicit win condition**; it is an open-ended toy where the fun is discovering weird and clever combinations, especially related to Turkish culture (e.g., *Ã§ay*, *simit*, *dolmuÅŸ*, *Ã‡ukur*, *AÅŸk-Ä± Memnu*, *Galatasaray*, *ekÅŸi sÃ¶zlÃ¼k memes*, etc.).

---

## 4. Strong Turkish-Culture Focus

### 4.1 Culture Prioritization

The AI must be guided so that:

- For any combination that can reasonably be answered with a **Turkish-local reference**, it should prefer that.
- If there is no obvious Turkish concept, it may:
    - Use a global concept but **transliterate properly it in Turkish**.

### 4.2 Types of Cultural Content

The AI is allowed to generate elements referencing:

- Turkish foods, places, historical events, folk tales, idioms.
- Turkish cinema, TV series, influencers, YouTubers, football clubs, etc.
- Turkish memes, internet slang, and trending concepts (as long as they are safe and non-hateful).
- Global concepts but described with a Turkish flavor.

The AI must *not* generate:

- Explicit sexual content, pornography, or sexual content involving minors.
- Hate speech, slurs, dehumanization of any group.
- Direct political propaganda or factional persuasion.
- Encouragement of violence, self-harm, terrorism, etc.

When in doubt, the system should **fallback to a harmless, neutral concept** (e.g., â€œKavramâ€ / â€œSoyut Fikirâ€).

---

## 5. Technical Architecture Overview

You can use any modern web stack. The architecture must support:

- **Frontend (Web)**:
    - Single-page app or modern web app.
    - Drag-and-drop UI.
    - Sidebar with search and scroll.
    - Local caching in browser.
- **Backend API**:
    - REST-ish JSON endpoints.
    - Database to store:
        - Elements
        - Combination results
        - User sessions / optional user accounts
    - Integration with **Google Gemini API**.
    - Basic server-side moderation and logging.
- **Database**:
    - Can be relational or NoSQL.
    - Must support:
        - Unique constraint on **(elementAId, elementBId)** pairs, **order-insensitive**.
        - Fast lookup of element names by ID.
        - Storing metadata like createdAt, firstDiscoveryUserId, etc.

---

## 6. Data Model

### 6.1 Element

Each **Element** entity should have at least:

- `id` (string or UUID)
- `name_tr` (string) â€” the primary displayed name in Turkish.
- `name_slug` (string) â€” slugified version of the Turkish name for URLs/search.
- `emoji` (string, optional) â€” for UI flair, e.g. â€œğŸ”¥â€, â€œğŸ‡¹ğŸ‡·â€.
- `description_tr` (string, optional) â€” short Turkish description (1â€“2 sentences).
- `tags` (array of strings) â€” e.g. `["meme", "yemek", "tarih"]`.
- `source` (enum/string) â€” `"seed"` or `"ai"`.
- `safety_flags` (array of strings) â€” if any (e.g., `"sensitive_religious"`, `"sports_rivalry"`).
- `created_at` (timestamp)

Starting elements (seed):

- AteÅŸ
- Su
- Toprak
- Hava

Seed elements should be inserted manually during initialization with `source = "seed"` and **never modified by AI**.

### 6.2 Combination

Each **Combination** entity:

- `id` (string or UUID)
- `element_a_id` (FK to Element)
- `element_b_id` (FK to Element)
- `result_element_id` (FK to Element)
- `order_invariant_key` (string)
    - e.g. `min(element_a_id, element_b_id) + ":" + max(element_a_id, element_b_id)`
    - Must be **unique** in the database.
- `first_discovery_user_id`
- `created_at` (timestamp)
- `ai_prompt` (string, optional) â€” snapshot of prompt used.
- `ai_raw_response` (string, optional) â€” raw response, for debugging.

### 6.3 User / Session

You may treat everyone as anonymous for v1, storing only:

- `session_id` (stored in cookie or local storage)
- List of element IDs discovered in that session

Add `users` table with `id`, `username`, etc.

---

## 7. API Design

### 7.1 Core Endpoints

**1. `POST /api/combine`**

Input JSON:

```json
{
  "elementAId": "string",
  "elementBId": "string",
  "sessionId": "optional-string"
}

```

Output JSON (success):

```json
{
  "result": {
    "element": {
      "id": "string",
      "name_tr": "string",
      "emoji": "string",
      "description_tr": "string",
      "tags": ["string"]
    },
    "isNewElementForSession": true,
    "isFirstEverCombination": true
  },
  "combinationId": "string"
}

```

Behavior:

- Normalize order via `order_invariant_key`.
- Fetch element A + B from DB.
- Call **Gemini** with formatted prompt (see section 8).
- Parse AI response into `name_tr`, `emoji`, `description_tr`, `tags`.
- Run safety checks.
- If unsafe â†’ fallback safe element (e.g., generic concept or â€œBoÅŸlukâ€).
- Insert new `Element` and `Combination`.
- Return `isFirstEverCombination = true`.

**2. `GET /api/elements`**

Parameters:

- `sessionId` (optional)
- `q` (optional search string)

Response:

```json
{
  "elements": [
    {
      "id": "string",
      "name_tr": "string",
      "emoji": "string"
    }
  ]
}

```

- Returns all elements the user has discovered in that session.
- Optionally allow â€œglobalâ€ view of all elements (for debug/admin).

**3. `POST /api/session`**

- Creates/initializes a session; returns `sessionId`.

---

## 8. Gemini API Integration (Mandatory)

### 8.1 Model Choice

- Use **Google Gemini API**.
- For v1, target a **text/generative** model such as:
    - `gemini-2.0-flash-lite`
- Make sure to externalize the model name and API key in configuration.

### 8.2 Request Endpoint (example)

**HTTP POST** to:

`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=YOUR_API_KEY`

Use official Gemini request format (JSON with `contents` including `role` and `parts`).

### 8.3 Prompt Design (For Combination Generation)

Whenever you combine Element A and Element B, send a prompt like:

**System / Instruction Context (pseudo):**

> You are an AI that designs single-word or short-phrase â€œelementsâ€ for a crafting game focused on Turkish culture and Turkish internet culture.
The player combines two existing elements to get a new result.
Your job: propose one new element name in Turkish, plus an emoji, plus a one-sentence Turkish description and some tags.
Prefer references from:
> 
> - Turkish internet culture, memes, social media, YouTube, EkÅŸi SÃ¶zlÃ¼k, etc.
> - Turkish daily life, foods, cities, TV shows, music, history, literature, sports.
> Be **creative** but **safe** and **non-offensive**.
> Avoid sexual content, explicit violence, hate speech, slurs, politics, and personal attacks.
> Never output more than one element. Never include explanations outside the JSON.

**User content (per request):**

```
Element A: "<NAME_TR_OF_ELEMENT_A>"
Description: "<DESCRIPTION_TR_OF_ELEMENT_A>"

Element B: "<NAME_TR_OF_ELEMENT_B>"
Description: "<DESCRIPTION_TR_OF_ELEMENT_B>"

Return a strict JSON object in the following format:

{
  "name_tr": "...",
  "emoji": "...",
  "description_tr": "...",
  "tags": ["...", "..."]
}

```

### 8.4 Expected Response Format

The server expects the LLM to return text that is a JSON object, like:

```json
{
  "name_tr": "Ã‡ay Sohbeti",
  "emoji": "â˜•",
  "description_tr": "TÃ¼rklerin Ã§ay eÅŸliÄŸinde yaptÄ±ÄŸÄ± uzun ve samimi muhabbet.",
  "tags": ["sosyal", "gÃ¼nlÃ¼k hayat", "TÃ¼rk kÃ¼ltÃ¼rÃ¼"]
}

```

Server must:

- Parse JSON.
- If parsing fails:
    - Retry once with a more strict prompt or simplified context.
    - If still fails, return a **fallback generic element**:
        - Name: `"Bilinmeyen Åey"`
        - Emoji: `"â“"`
        - Description: `"AI bu kombinasyon iÃ§in net bir ÅŸey bulamadÄ±, ama merak uyandÄ±ran bir bilinmeyen."`

### 8.5 Safety & Moderation Layer

After parsing, the server should run simple rule-based checks:

- Lowercase `name_tr` and `description_tr`.
- Check against a **blocklist** of:
    - Slurs
    - Explicit sex terms
    - Obvious political party names / candidates (to avoid factional propaganda)
    - Terror organizations
- If something is flagged:
    - Do **not** throw error.
    - Replace with safe fallback element:
        - e.g., `"GÃ¼venli Kavram"`, `"ğŸ¤"`, `"TartÄ±ÅŸmalÄ± iÃ§erik yerine gÃ¼venli bir kavram Ã¼retildi."`

Make a secondary Gemini call in a **moderation mode**:
e.g., ask it: â€œLabel this content as safe/unsafe + reasons.â€

---

## 9. UI / UX Specification

### 9.1 Layout

- **Top Bar:**
    - Game title: â€œSonsuz TÃ¼rkiyeâ€
    - Buttons:
        - â€œAyarlarâ€ (Settings)
        - â€œTemaâ€ (Light/Dark toggle)
        - â€œHakkÄ±ndaâ€ (About)
- **Right Sidebar:**
    - Title: â€œKeÅŸfettiklerinâ€
    - Search bar: filter elements by name.
    - Scrollable list of elements:
        - Each row: `emoji + name_tr`
    - Option to **pin** favorite elements to top.
- **Main Canvas (Center/Left):**
    - Empty grid or subtle background.
    - Drag area where elements can be dropped.
    - When elements are dropped onto each other, show:
        - Small combining animation (e.g., glow/merge).
        - Result appears in the drop location.
    - Allow dragging multiple copies of the same element.

### 9.2 Interactions

- **Drag & Drop:**
    - Drag from sidebar â†’ canvas.
    - Drag an element on canvas onto another on canvas to trigger combination.
- **Click-to-Combine (Accessibility fallback):**
    - Click element A â†’ highlight.
    - Click element B â†’ attempt combination.
    - Show result in element B's place.
- **Element Tooltip:**
    - On hover / tap:
        - Show `description_tr` in a small tooltip.
- **First Discovery UI:**
    - When a new combination is generated for the first time ever:
        - Show a small badge near the result: â€œÄ°lk KeÅŸif!â€
        - Track this locally.

### 9.3 Visual Style

- Clean, minimalist.
- Use emojis heavily as visual anchors.
- Colors:
    - Calm neutrals (white, light gray) with one accent color: turkish flag red.
- Dark mode:
    - Invert appropriate colors; keep emojis legible.

---

## 10. Game Logic Details

### 10.1 Combination Rules

- **Order-insensitive**:
    - `Su + AteÅŸ` should be treated the same as `AteÅŸ + Su`.
- **No Self-Combination Restrictions**:
    - `Galatasaray + Galatasaray` is allowed; results may be meta (e.g. â€œUltraAslanâ€).
- **Duplicate Result Handling**:
    - AI might create an element name that already exists:
        - If `name_tr` matches an existing element (case-insensitive, normalized):
            - Reuse that existing element instead of creating a new one.
- **Max Element Name Length**:
    - For UI: max 40 characters.
    - If AI returns longer name, truncate gracefully.

### 10.2 Session Progress

- For each `sessionId`, track:
    - List of discovered element IDs.
- On `/api/elements`, return only those, ordered:
    - Seed elements first.
    - Then by `created_at` or discovery time.
- Store in browser `localStorage` for quick reloads.

---

## 11. Content & Culture Examples

These are **examples to shape the AI prompt behavior** and do not need to be pre-seeded.

- `Su + Toprak â†’ Ã‡amur`
- `Ã‡ay + Sohbet â†’ Ã‡ay Muhabbeti`
- `Ä°stanbul + Trafik â†’ E-5 Kabusu`
- `DolmuÅŸ + BaÄŸÄ±rmak â†’ Muavin`
- `AteÅŸ + Toprak â†’ Volkan`
- `Televizyon + Dram â†’ TÃ¼rk Dizisi`
- `Ã‡ay + Simit â†’ KahvaltÄ± Keyfi`
- `Ã–ÄŸrenci + Gece â†’ Vize`
- `Futbol + Kavga â†’ Derbi GerginliÄŸi`

AI should aim for this flavor: **recognizable Turkish contexts + gen z humor.**

Keep these and additionals in an examples list somewhere and use it from there so that we can change it later on dynamically.

---

## 12. Settings & Config

- **Language:** Fixed Turkish UI. Later you can add English as alternate.
- **Sound Effects:**
    - Soft â€œpopâ€ sound on combination.
- **Performance:**
    - Limit number of visible objects on canvas; older ones can be faded or removed.
- **Rate Limiting:**
    - Soft-limit Gemini calls per session to avoid abuse.
    - If limit hit, show message:
    `"BugÃ¼n Ã§ok Ã¼retken Ã§Ä±ktÄ±n! Biraz dinlen, sonra devam edelim."`

---

## 13. Logging & Analytics (Basic)

- Log every combination request:
    - `element_a_id`, `element_b_id`, `result_element_id`, timestamp.
- Aggregate stats:
    - Most popular elements.
    - Most frequent pairs.
- These should be available via an internal admin endpoint (e.g. `/admin/stats`).

---

## 14. Non-Functional Requirements

- **Responsiveness:**
The app must be usable on:
    - Desktop browsers
    - Mobile and tablet browsers
- **Performance:**
    - Combining elements should feel snappy.
    - Use caching so repeated pairs do not call Gemini.
- **Stability:**
    - If Gemini API is down or fails repeatedly:
        - Show friendly message and fallback elements.

---

## 15. Scope Summary

**Must-Haves:**

- Web app with:
    - Sidebar of elements (with 4 starting elements).
    - Canvas drag-and-drop to combine elements.
- Backend with:
    - Elements + Combinations tables/collections.
    - Pair â†’ element mapping.
    - Gemini API integration with custom prompt and JSON format.
    - Simple safety layer (blocklist, fallback element).
- Basic â€œfirst discoveryâ€ indicator (only per-session).
- Turkish-focused AI outputs.

**Nice-to-Haves (Optional for v1):**

- Dark mode toggle.
- Sounds.
- Admin stats page.

---

## 16. Post-Reporting

Prepare and/or modify these documents while in development and after development:

- README.md
    - This document should have two subsections:
        1. End-user targeting subsection: This is where you explain what the project is, how to use it excâ€¦
        2. Developer targeting subsection: This is where you explain the project to a developer that is interested in the project or want to locally run, install, do developer stuff about the project excâ€¦
- DevelopmentSummary.md
    - You will explain what you have done, how you have done them, personal recommendations on current version and future versions in all of the subsections.
    - This document should have three subsections:
        1. Executive summary subsection: Summarize what you have done to someone that has really small time.
        2. Business manager subsection: Explain what you have done business-wise and game-design-wise to a manager that is interested in the productâ€™s non-technical but practical side.
        3. Tech lead subsection: Explain what you have done technically, how you have done them, why you have done them all in detail to a tech lead that cares about the inner working of the project.